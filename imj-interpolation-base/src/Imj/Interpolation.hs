{-# LANGUAGE NoImplicitPrelude #-}

-- | Defines the notion of interpolation between two values of the same type.

module Imj.Interpolation
         ( DiscretelyInterpolable(..)
         -- * Instances
         , SequentiallyInterpolatedList(..)
         , Successive(..)
         -- * Reexports
         , module Imj.Iteration
         ) where

import           Imj.Prelude

import           Control.Monad.IO.Class(MonadIO)
import           Control.Monad.Reader.Class(MonadReader)

import           Data.List( length, mapAccumL, splitAt )
import           Data.Text(pack)

import           Imj.Color.Interpolate
import           Imj.Draw.Class
import           Imj.Geo.Discrete
import           Imj.Geo.Discrete.Bresenham
import           Imj.Iteration
import           Imj.Text.ColorString
import           Imj.Util


newtype Successive a = Successive [a] deriving(Show)

{- | The instances of this class should statisfy the following constraints:

* An interpolation between A and B starts at A and ends at B:

\[ \forall (\, from, to)\, \in v, \]

@
    d = distance from to
    interpolate from to 0 == from
    interpolate from to d == to
@

* The interpolation path is composed of strictly distinct points:

@
    length $ nubOrd $ map (interpolate from to) [0..pred d] == d
@

* Given any points A,B belonging the path generated by an interpolation,
  the interpolation beween A and B will be the points of the path between A and B:

\[ \forall med \in [\,0,d]\,, \forall low \in [\,0,med]\,, \forall high \in [\,med,d]\,, \]

@
    distance from med + distance med to == 1 + distance from to
    medVal = interpolate from to med
    interpolate from to low  == interpolate from medVal low
    interpolate from to high == interpolate medVal to $ high-med
@
-}
class (Show v) => DiscretelyInterpolable v where

  -- | Special case where the interpolation is between 2 values
  distance :: v -- ^ first value
           -> v -- ^ last value
           -> Int -- ^ the number of steps (including first and last) to go from first to last

  -- | General case where the interpolation goes through n values
  distanceSuccessive :: Successive v
                     -> Int
  distanceSuccessive (Successive []) =
    error "empty successive"
  distanceSuccessive (Successive l@(_:_)) =
    succ $ sum $ zipWith (\a b -> pred $ distance a b) l $ tail l

  interpolate :: v -- ^ first value
              -> v -- ^ last value
              -> Int -- ^ the current step
              -> v -- ^ the interpolated value
  interpolate = error "interpolate is not defined"

  interpolateIO :: (Draw e, MonadReader e m, MonadIO m)
                => v -- ^ first value
                -> v -- ^ last value
                -> Int -- ^ the current step
                -> m ()
  interpolateIO = error "interpolateIO is not defined"

  interpolateSuccessive :: Successive v
                        -> Int
                        -> v
  interpolateSuccessive (Successive []) _ = error "empty successive"
  interpolateSuccessive (Successive [a]) _ = a
  interpolateSuccessive (Successive l@(a:b:_)) i
    | i <= 0      = a
    | i >= lf = interpolateSuccessive (Successive $ tail l) $ i-lf
    | otherwise = interpolate a b i
    where lf = pred $ distance a b

  {-# INLINABLE interpolateSuccessiveIO #-}
  interpolateSuccessiveIO :: (Draw e, MonadReader e m, MonadIO m)
                          => Successive v
                          -> Int
                          -> m ()
  interpolateSuccessiveIO (Successive []) _ = error "empty successive"
  interpolateSuccessiveIO (Successive [a]) _ = interpolateIO a a 0
  interpolateSuccessiveIO (Successive l@(a:b:_)) i
    | i <= 0      = interpolateIO a a 0
    | i >= lf = interpolateSuccessiveIO (Successive $ tail l) $ i-lf
    | otherwise = interpolateIO a b i
    where lf = pred $ distance a b


instance DiscretelyInterpolable Int where
  distance i i' =
    1 + abs (i-i')
  interpolate i i' progress =
    i + signum (i'-i) * clamp progress 0 (abs (i-i'))


-- | Interpolation between 2 lists, occuring in parallel between same-index elements.
--   Prerequisite : lists have the same lengths.
--
--  For an interpolation that occurs sequentially between same-index elements,
--   use SequentiallyInterpolatedList.
instance (DiscretelyInterpolable a)
      => DiscretelyInterpolable ([] a) where
  distance [] _ = 1
  distance _ [] = 1
  distance l l' =
    maximum $ zipWith distance l $ assert (length l == length l') l'

  interpolate l l' progress =
    zipWith (\e e' -> interpolate e e' progress) l $ assert (length l == length l') l'


newtype SequentiallyInterpolatedList a =
  SequentiallyInterpolatedList [a]
  deriving(Eq, Ord, Show)

-- | Interpolation between 2 SequentiallyInterpolatedList, occuring sequentially
--   between same-index elements.
--   Prerequisite : lists have the same lengths.
--
--  For an interpolation that occurs in parallel, use [].
instance (DiscretelyInterpolable a)
      => DiscretelyInterpolable (SequentiallyInterpolatedList a) where

  distance (SequentiallyInterpolatedList l) (SequentiallyInterpolatedList l') =
    succ $ sum $ zipWith (\x y -> pred $ distance x y) l (assert (length l' == length l) l')

  interpolate (SequentiallyInterpolatedList l) (SequentiallyInterpolatedList l') progress =
    SequentiallyInterpolatedList $ snd $
      mapAccumL
        (\acc (e,e') ->
          let d = pred $ distance e e'
              r = interpolate e e' $ clamp acc 0 d
          in (acc-d, r))
        progress
        $ zip l (assert (length l' == length l) l')


instance DiscretelyInterpolable Coords where
  distance = bresenhamLength

  interpolate c c' i
    | c == c' = c
    | otherwise =
        let lastFrame = pred $ fromIntegral $ bresenhamLength c c'
            -- TODO measure if "head . drop (pred n)"" is more optimal than "!! n"
            index = clamp i 0 lastFrame
        in head . drop index $ bresenham $ mkSegment c c'

instance DiscretelyInterpolable (Color8 a) where
  -- | The two input 'Color8' are supposed to be both 'rgb' or both 'gray'.
  distance = bresenhamColor8Length

  -- | The two input 'Color8' are supposed to be both 'rgb' or both 'gray'.
  interpolate c c' i
    | c == c' = c
    | otherwise =
        let lastFrame = pred $ fromIntegral $ bresenhamColor8Length c c'
            -- TODO measure if "head . drop (pred n)"" is more optimal than "!! n"
            index = clamp i 0 lastFrame
        in head . drop index $ bresenhamColor8 c c'


-- TODO bresenham 6 to interpolate foreground and background at the same time:
-- https://nenadsprojects.wordpress.com/2014/08/08/multi-dimensional-bresenham-line-in-c/
-- | First interpolate background color, then foreground color
instance DiscretelyInterpolable LayeredColor where
  distance (LayeredColor bg fg) (LayeredColor bg' fg') =
    succ $ pred (distance bg bg') + pred (distance fg fg')

  interpolate (LayeredColor bg fg) (LayeredColor bg' fg') i
    | i < lastBgFrame = LayeredColor (interpolate bg bg' i) fg
    | otherwise       = LayeredColor bg' $ interpolate fg fg' $ i - lastBgFrame
    where
      lastBgFrame = pred $ distance bg bg'

-- TODO maybe it would be faster to have a representation with Array (Char, LayeredColor)
--  (ie the result of simplify)
instance DiscretelyInterpolable ColorString where
  distance c1 c2 =
    let colorDist (_, color) (_, color') =
          distance color color'
        n1 = countChars c1
        n2 = countChars c2
        s1 = simplify c1
        s2 = simplify c2

        (c1', remaining) = interpolateChars c1 c2 countTextChanges
        s1' = simplify $ assert (remaining == 0) c1'
        l = zipWith colorDist s1' s2 -- since color interpolation happends AFTER char changes,
                                     -- we compare colors with result of char interpolation
        colorDistance =
          if null l
            then
              1
            else
              maximum l

        toString = map fst
        str1 = toString s1
        str2 = toString s2
        lPref = length $ commonPrefix str1 str2
        lSuff = length $ commonSuffix (drop lPref str1) (drop lPref str2)
        countTextChanges = max n1 n2 - (lPref + lSuff)
    in colorDistance + countTextChanges

  interpolate c1 c2 i =
    let (c1', remaining) = interpolateChars c1 c2 i
    in if remaining >= 0
         then
           c1'
          else
            interpolateColors c1' c2 (negate remaining)


interpolateChars :: ColorString
                 -- ^ from
                 -> ColorString
                 -- ^ to
                 -> Int
                 -- ^ progress
                 -> (ColorString, Int)
                 -- ^ (result,nSteps)
                 --             | >=0 : "remaining until completion"
                 --             | <0  : "completed since" (using abolute value))
interpolateChars c1 c2 i =
  let n1 = countChars c1
      n2 = countChars c2
      s1 = simplify c1
      s2 = simplify c2

      toString = map fst
      str1 = toString s1
      str2 = toString s2
      lPref = length $ commonPrefix str1 str2
      lSuff = length $ commonSuffix (drop lPref str1) (drop lPref str2)

      -- common prefix, common suffix

      (commonPref, s1AfterCommonPref) = splitAt lPref s1
      commonSuff = drop (n1 - (lSuff + lPref)) s1AfterCommonPref

      -- common differences (ie char changes)

      totalCD = min n1 n2 - (lPref + lSuff)
      nCDReplaced = clamp i 0 totalCD

      s2AfterCommonPref = drop lPref s2
      -- TODO use source color when replacing a char (color will be interpolated later on)
      cdReplaced = take nCDReplaced s2AfterCommonPref

      nCDUnchanged = totalCD - nCDReplaced
      cdUnchanged = take nCDUnchanged $ drop nCDReplaced s1AfterCommonPref

      -- exclusive differences (ie char deletion or insertion)
      -- TODO if n1 > n2, reduce before replacing
      signedTotalExDiff = n2 - n1
      signedNExDiff = signum signedTotalExDiff * clamp (i - totalCD) 0 (abs signedTotalExDiff)
      (nExDiff1,nExDiff2) =
        if signedTotalExDiff >= 0
          then
            (0, signedNExDiff)
          else
            (abs $ signedTotalExDiff - signedNExDiff, 0)
      ed1 = take nExDiff1 $ drop totalCD s1AfterCommonPref
      ed2 = take nExDiff2 $ drop totalCD s2AfterCommonPref

      remaining = (totalCD + abs signedTotalExDiff) - i

  in (ColorString
      $ map (\(char,color) -> (pack [char], color))
      $ commonPref ++ cdReplaced ++ cdUnchanged ++ ed1 ++ ed2 ++ commonSuff
      , assert (remaining == max n1 n2 - (lPref + lSuff) - i) remaining)

interpolateColors :: ColorString
                  -- ^ from
                  -> ColorString
                  -- ^ to
                  -> Int
                  -- ^ progress
                  -> ColorString
interpolateColors c1 c2 i =
  let itp (_, color)
          (char, color') =
        (pack [char], interpolate color color' i)
  in ColorString $ zipWith itp (simplify c1) (simplify c2)
